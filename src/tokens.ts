import { SyntaxKind } from "@ts-morph/ts-morph";

export const SKIP_KINDS = new Set([
  SyntaxKind.AmpersandAmpersandToken,
  SyntaxKind.AmpersandToken,
  SyntaxKind.AsteriskEqualsToken,
  SyntaxKind.AsteriskToken,
  SyntaxKind.AtToken,
  SyntaxKind.BacktickToken,
  SyntaxKind.BarBarToken,
  SyntaxKind.CaretToken,
  SyntaxKind.CloseBraceToken,
  SyntaxKind.CloseBracketToken,
  SyntaxKind.CloseParenToken,
  SyntaxKind.ColonToken,
  SyntaxKind.CommaToken,
  SyntaxKind.DotDotDotToken,
  SyntaxKind.DotToken,
  SyntaxKind.EndOfFileToken,
  SyntaxKind.EqualsEqualsEqualsToken,
  SyntaxKind.EqualsEqualsToken,
  SyntaxKind.EqualsGreaterThanToken,
  SyntaxKind.EqualsToken,
  SyntaxKind.ExclamationEqualsEqualsToken,
  SyntaxKind.ExclamationEqualsToken,
  SyntaxKind.ExclamationToken,
  SyntaxKind.GreaterThanEqualsToken,
  SyntaxKind.GreaterThanToken,
  SyntaxKind.HashToken,
  SyntaxKind.JsxClosingElement,
  SyntaxKind.JsxText,
  SyntaxKind.LessThanEqualsToken,
  SyntaxKind.LessThanToken,
  SyntaxKind.MinusEqualsToken,
  SyntaxKind.MinusToken,
  SyntaxKind.OpenBraceToken,
  SyntaxKind.OpenBracketToken,
  SyntaxKind.OpenParenToken,
  SyntaxKind.PercentToken,
  SyntaxKind.PlusEqualsToken,
  SyntaxKind.PlusToken,
  SyntaxKind.QuestionDotToken,
  SyntaxKind.QuestionQuestionToken,
  SyntaxKind.QuestionToken,
  SyntaxKind.SemicolonToken,
  SyntaxKind.SlashEqualsToken,
  SyntaxKind.SlashToken,
  SyntaxKind.StringKeyword,
  SyntaxKind.TildeToken,
  SyntaxKind.GreaterThanGreaterThanToken,

  SyntaxKind.AbstractKeyword,
  SyntaxKind.AnyKeyword,
  SyntaxKind.AsKeyword,
  SyntaxKind.AsyncKeyword,
  SyntaxKind.BigIntKeyword,
  SyntaxKind.BooleanKeyword,
  SyntaxKind.BreakKeyword,
  SyntaxKind.CaseKeyword,
  SyntaxKind.CatchKeyword,
  SyntaxKind.ClassKeyword,
  SyntaxKind.ConstKeyword,
  SyntaxKind.ContinueKeyword,
  SyntaxKind.DebuggerKeyword,
  SyntaxKind.DeclareKeyword,
  SyntaxKind.DefaultKeyword,
  SyntaxKind.DeferKeyword,
  SyntaxKind.DoKeyword,
  SyntaxKind.ElseKeyword,
  SyntaxKind.EnumKeyword,
  SyntaxKind.ExportKeyword,
  SyntaxKind.ExtendsKeyword,
  SyntaxKind.FalseKeyword,
  SyntaxKind.FinallyKeyword,
  SyntaxKind.ForKeyword,
  SyntaxKind.FromKeyword,
  SyntaxKind.FunctionKeyword,
  SyntaxKind.IfKeyword,
  SyntaxKind.ImplementsKeyword,
  SyntaxKind.InKeyword,
  SyntaxKind.IsKeyword,
  SyntaxKind.KeyOfKeyword,
  SyntaxKind.NeverKeyword,
  SyntaxKind.NullKeyword,
  SyntaxKind.NumberKeyword,
  SyntaxKind.OfKeyword,
  SyntaxKind.OverrideKeyword,
  SyntaxKind.PrivateKeyword,
  SyntaxKind.ProtectedKeyword,
  SyntaxKind.PublicKeyword,
  SyntaxKind.ReadonlyKeyword,
  SyntaxKind.StaticKeyword,
  SyntaxKind.SuperKeyword,
  SyntaxKind.SymbolKeyword,
  SyntaxKind.ThisKeyword,
  SyntaxKind.TrueKeyword,
  SyntaxKind.TypeOfKeyword,
  SyntaxKind.UndefinedKeyword,
  SyntaxKind.UniqueKeyword,
  SyntaxKind.UnknownKeyword,
  SyntaxKind.VoidKeyword,

  SyntaxKind.StringLiteral,
  SyntaxKind.NoSubstitutionTemplateLiteral,
  SyntaxKind.TemplateHead,
  SyntaxKind.TemplateTail,
  SyntaxKind.TemplateMiddle,

  // Skip type nodes
  SyntaxKind.ArrayType,
  SyntaxKind.TypeReference,
  SyntaxKind.InterfaceDeclaration,
  SyntaxKind.UnionType,
  SyntaxKind.TypeAliasDeclaration,
  SyntaxKind.TypeLiteral,
  SyntaxKind.RegularExpressionLiteral,
  SyntaxKind.TypeOperator,
  SyntaxKind.TypeParameter,
  SyntaxKind.FunctionType,
  SyntaxKind.IndexedAccessType,
  SyntaxKind.TypePredicate,
  SyntaxKind.TupleType,
  SyntaxKind.NamedTupleMember,
  SyntaxKind.IntersectionType,
  SyntaxKind.MappedType,
]);

export const PASS_THROUGH_KINDS = new Set([
  SyntaxKind.ArrayBindingPattern,
  SyntaxKind.ArrayLiteralExpression,
  SyntaxKind.ArrowFunction,
  SyntaxKind.AsExpression,
  SyntaxKind.AwaitExpression,
  SyntaxKind.BinaryExpression,
  SyntaxKind.BindingElement, // This one should be a definition maybe ?
  SyntaxKind.Block,
  SyntaxKind.CallExpression,
  SyntaxKind.CatchClause,
  SyntaxKind.ConditionalExpression,
  SyntaxKind.ContinueStatement,
  SyntaxKind.ElementAccessExpression,
  SyntaxKind.ExportDeclaration,
  SyntaxKind.ExportKeyword,
  SyntaxKind.ExportSpecifier,
  SyntaxKind.ExpressionStatement,
  SyntaxKind.ForOfStatement,
  SyntaxKind.FunctionExpression,
  SyntaxKind.IfStatement,
  SyntaxKind.ImportClause,
  SyntaxKind.ImportDeclaration,
  SyntaxKind.ImportSpecifier,
  SyntaxKind.InstanceOfKeyword,
  SyntaxKind.JsxAttribute,
  SyntaxKind.JsxAttributes,
  SyntaxKind.JsxElement,
  SyntaxKind.JsxExpression,
  SyntaxKind.JsxOpeningElement,
  SyntaxKind.JsxSelfClosingElement,
  SyntaxKind.JsxSpreadAttribute,
  SyntaxKind.NamedExports,
  SyntaxKind.NamedImports,
  SyntaxKind.NamespaceImport,
  SyntaxKind.NewExpression,
  SyntaxKind.NonNullExpression,
  SyntaxKind.NumericLiteral,
  SyntaxKind.ObjectBindingPattern,
  SyntaxKind.ObjectLiteralExpression,
  SyntaxKind.Parameter,
  SyntaxKind.ParenthesizedExpression,
  SyntaxKind.PrefixUnaryExpression,
  SyntaxKind.PropertyAccessExpression,
  SyntaxKind.PropertyAssignment,
  SyntaxKind.PropertySignature,
  SyntaxKind.ReturnStatement,
  SyntaxKind.ShorthandPropertyAssignment,
  SyntaxKind.SpreadAssignment,
  SyntaxKind.SpreadElement,
  SyntaxKind.TaggedTemplateExpression,
  SyntaxKind.TemplateExpression,
  SyntaxKind.TemplateSpan,
  SyntaxKind.ThrowStatement,
  SyntaxKind.TryStatement,
  SyntaxKind.VariableDeclarationList,
  SyntaxKind.VariableStatement,
  SyntaxKind.ClassDeclaration,
  SyntaxKind.HeritageClause,
  SyntaxKind.ExpressionWithTypeArguments,
  SyntaxKind.Constructor,
  SyntaxKind.WhileStatement,
  SyntaxKind.ForStatement,
  SyntaxKind.PostfixUnaryExpression,
  SyntaxKind.TypeOfExpression,
  SyntaxKind.CaseBlock,
  SyntaxKind.SwitchStatement,
  SyntaxKind.CaseClause,
  SyntaxKind.SatisfiesExpression,
  SyntaxKind.MethodDeclaration,
  SyntaxKind.BreakStatement,
  SyntaxKind.DefaultClause,
  SyntaxKind.MetaProperty,
  SyntaxKind.ForInStatement,
  SyntaxKind.ComputedPropertyName,
  SyntaxKind.DeleteExpression,
  SyntaxKind.YieldExpression,
  SyntaxKind.JsxFragment,
  SyntaxKind.JsxOpeningFragment,
  SyntaxKind.JsxClosingFragment,
]);

export const STOP_KIND: SyntaxKind | null = null;
